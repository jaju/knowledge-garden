[
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Welcome to the blog.\nBlog posts are published once and remain unchanged.\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notes/index.html",
    "href": "notes/index.html",
    "title": "Notes",
    "section": "",
    "text": "Evolving notes. Content here is updated over time.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nNotes: LLM From Scratch\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notes/llm-from-scratch/index.html",
    "href": "notes/llm-from-scratch/index.html",
    "title": "Notes: LLM From Scratch",
    "section": "",
    "text": "Notes and pointers during the exploration of the book LLM From Scratch by Sebastian Raschka. While I am using this book as the central reference, the notes will contain additional references and pointers to other resources."
  },
  {
    "objectID": "notes/llm-from-scratch/index.html#key-challenges-in-pre-training",
    "href": "notes/llm-from-scratch/index.html#key-challenges-in-pre-training",
    "title": "Notes: LLM From Scratch",
    "section": "2.1 Key challenges in pre-training",
    "text": "2.1 Key challenges in pre-training\n\nData: Creating or curating a large corpus of text data is a significant challenge. The quality and diversity of the data are crucial for the performance of the model.\nModel: The model architecture is key for pre-training. A good model architecture will help in learning the underlying structure of the data.\nBudget: Pre-training a large language model requires a lot of computational resources. A good budget is crucial for pre-training.\nGPT-3 potentially cost $4.6 million to train, per Li (2020).\n\nOuyang et al. (2022) presented ideas on how to fine-tune GPT-3 on a dataset of instructions."
  },
  {
    "objectID": "notes/llm-from-scratch/index.html#tokenization",
    "href": "notes/llm-from-scratch/index.html#tokenization",
    "title": "Notes: LLM From Scratch",
    "section": "3.1 Tokenization",
    "text": "3.1 Tokenization\nThe more tokens we have, the more information we can capture. However, more tokens also mean more computational resources.\n\n\n\n\n\n\nHow does the token vocabulary affect computation?\n\n\n\n\n\n\nThe number of tokens affects the size of the embedding matrix.\nThe embedding matrix is a lookup table that maps each token to its corresponding embedding vector.\nThe size of the embedding matrix is determined by the vocabulary size and the embedding dimension. The larger the vocabulary, the larger the embedding matrix, and the more memory and computation are required to process it.\n\n\n\n\n\nTokens can be created not just for words, but also for subwords and characters.\nThis allows us to capture more information, and handle “words” not seen before.\nWe do not encode grammar rules (which are hard to define and may not be exhaustive or easy to update). Instead, we let the model learn the rules from the data. This is a key difference between traditional NLP and deep learning NLP.\n\n\nimport importlib\nimport stage1.tokenization\nimportlib.reload(stage1.tokenization)\n\n&lt;module 'stage1.tokenization' from '/Users/jaju/github/knowledge-garden/notes/llm-from-scratch/stage1/tokenization.py'&gt;\n\n\n\n3.1.1 V1\nThe first, naive implementation that can not handle unseen tokens, as tokens are identified based on word boundaries from the training text.\n\nstage1.tokenization.v1()\n\nError: Token 'draggees' not found in vocab.\n\n\n\n\n3.1.2 V2\nAbility to handle unseen tokens, plus additional signals to like begin/end of text, padding, etc. We simply preprocess the text to handle unseen tokens and replace then with a special token.\n\nstage1.tokenization.v2()\n\n\n2025-08-10 18:18:29.779 | INFO     | utils.downloaders:download:21 - data/the_verdict.txt already exists. Skipping download.\n\n\n\n\n╒═════════╤════════════════════════════╕\n│ Input   │ three she draggees equally │\n├─────────┼────────────────────────────┤\n│ Encoded │ [1004, 876, 1131, 394]     │\n├─────────┼────────────────────────────┤\n│ Decoded │ three she &lt;|unk|&gt; equally  │\n╘═════════╧════════════════════════════╛\n\n\n\n\n3.1.3 V3 - Byte Pair Encoding (BPE)\n\nUsed in the original ChatGPT as well as GPT-2 and GPT-3.\n\nThis one goes further granular in how it identifies tokens - encompassing all atomic units and then certain agglomerations of them.- This is a data-driven approach to tokenization, where we learn the tokens from the data.\n\ntiktoken is a Python implementation of BPE. Implementation from scratch is not a key aim of this book, but it is useful to understand the concepts.\n\nIn this example, we don’t create a new vocabulary, but use the ‘GPT-2’ vocabulary. (See source)\n\nstage1.tokenization.v3()\n\n\n2025-08-10 18:18:29.785 | INFO     | utils.downloaders:download:21 - data/the_verdict.txt already exists. Skipping download.\n\n\n\n\n╒═════════╤════════════════════════════════════╕\n│ Input   │ three she draggees equally         │\n├─────────┼────────────────────────────────────┤\n│ Encoded │ [15542, 673, 6715, 469, 274, 8603] │\n├─────────┼────────────────────────────────────┤\n│ Decoded │ three she draggees equally         │\n╘═════════╧════════════════════════════════════╛\n\n\nNotice that the number of tokens is more than the number of distinct words in this example. We also have unseen words, which are split into multiple tokens that are in the vocabulary. This is a key feature of BPE, as it allows us to handle unseen words by breaking them down into smaller units that are in the vocabulary.\n\n\n3.1.4 V4\nThis is a further improvement over the previous version. “Improvement” not because of the tokenization technique but because of how we inject special symbols into the text. We use a special token to indicate the beginning and end of a sentence, and a special token to indicate padding.\n\nstage1.tokenization.v4()\n\n\n2025-08-10 18:18:29.890 | INFO     | utils.downloaders:download:21 - data/the_verdict.txt already exists. Skipping download.\n\n\n\n\n╒═════════╤═══════════════════════════════════════════════════════════════════════════════╕\n│ Input   │ three she dragged equally. &lt;|endoftext|&gt; This is the end of the document.     │\n├─────────┼───────────────────────────────────────────────────────────────────────────────┤\n│ Encoded │ [15542, 673, 17901, 8603, 13, 220, 50256, 770, 318, 262, 886, 286, 262, 3188, │\n│         │ 13]                                                                           │\n├─────────┼───────────────────────────────────────────────────────────────────────────────┤\n│ Decoded │ three she dragged equally. &lt;|endoftext|&gt; This is the end of the document.     │\n╘═════════╧═══════════════════════════════════════════════════════════════════════════════╛\n\n\n\n3.1.4.1 BPE: A further demonstration\nBPE can handle (apparently) garbage text. And also, it preserves spaces between tokens, because it makes no special assumptions about the text, including the notion of word boundaries.\n\nstage1.tokenization.v4bpe()\n\n╒═════════╤═════════════════════════════════════════════════════════════════════════════════╕\n│ Input   │ asd asdjfkjsdf ksjfksa sdkfjsj   powiuosadoapofqfvv                             │\n├─────────┼─────────────────────────────────────────────────────────────────────────────────┤\n│ Encoded │ [292, 67, 355, 28241, 69, 74, 8457, 7568, 479, 82, 73, 69, 591, 64, 264, 34388, │\n│         │ 69, 8457, 73, 220, 220, 7182, 16115, 418, 4533, 499, 1659, 80, 69, 25093]       │\n├─────────┼─────────────────────────────────────────────────────────────────────────────────┤\n│ Decoded │ asd asdjfkjsdf ksjfksa sdkfjsj   powiuosadoapofqfvv                             │\n╘═════════╧═════════════════════════════════════════════════════════════════════════════════╛"
  },
  {
    "objectID": "notes/llm-from-scratch/index.html#embeddings",
    "href": "notes/llm-from-scratch/index.html#embeddings",
    "title": "Notes: LLM From Scratch",
    "section": "3.2 Embeddings",
    "text": "3.2 Embeddings\n\nTokens as 1-hot vectors create sparse matrices that are inefficient and fail to capture semantic relationships\nEmbeddings represent tokens in a lower-dimensional space that preserves semantic relationships\nEmbeddings are learned, not universal representations, and are specific to the model they’re trained in\nThe embedding space dimension is a tunable hyperparameter (larger = more informative but more resource-intensive)\nEmbeddings start as random values and are refined during training through gradient updates\n\n\nimport importlib\nimport stage1.embeddings\nimportlib.reload(stage1.embeddings)\n\n&lt;module 'stage1.embeddings' from '/Users/jaju/github/knowledge-garden/notes/llm-from-scratch/stage1/embeddings.py'&gt;\n\n\n\n3.2.1 What do they look like?\nLet’s create a randomly initialized embedding matrix for a vocabulary of size 10 and an embedding dimension of 4. The embeddings matrix is then of size (10, 4), where each row corresponds to a token in the vocabulary and each column corresponds to a dimension in the embedding space.\n\nimport torch\nimport stage1.embeddings\nembedding_dim = 4\nvocab_size = 10\n\nembeddings = torch.nn.Embedding(vocab_size, embedding_dim)\nprint(embeddings.weight)\nprint(f\"Embedding of token-id 2 is {embeddings(torch.tensor([1]))}\")\n\nParameter containing:\ntensor([[ 0.5681,  1.3156, -1.1681, -0.1468],\n        [ 1.0959,  1.0497, -0.3855,  0.2652],\n        [-0.8270,  0.1451, -0.6180, -2.1681],\n        [ 0.3374,  0.5199, -0.4277,  0.3758],\n        [-0.0170,  1.2219,  1.4865, -0.4767],\n        [-0.5105, -1.1597,  1.5071,  0.8703],\n        [ 1.0197, -0.4430, -1.1768, -0.7499],\n        [-0.3121,  0.7563, -0.8407, -0.0094],\n        [ 0.4255,  0.2792, -0.5903, -1.0489],\n        [-1.8055,  0.6865,  0.0475,  1.1657]], requires_grad=True)\nEmbedding of token-id 2 is tensor([[ 1.0959,  1.0497, -0.3855,  0.2652]], grad_fn=&lt;EmbeddingBackward0&gt;)\n\n\nThe embedding of a token with id i is simply the i-th row of the embedding matrix. For example, the embedding of the token with id 0 is the first row of the embedding matrix. Mapping tokens to embeddings is plainly a lookup operation.\n\n\n3.2.2 V0\nPrinting the embedding matrix of a made-up vocabulary. The embeddings are randomly initialized. The embeddings matrix size is determined by the vocabulary size and the embedding dimension. The embedding dimension is a hyperparameter that can be tuned.\nEmbeddings are tensors with a shape of (vocab_size, embedding_dim).\n\nimport torch.nn as nn\nnn.Embedding(10, 4).weight\n\nParameter containing:\ntensor([[-0.8666,  0.5709, -0.4242, -1.8706],\n        [-1.1113,  1.7278, -1.1033,  0.1828],\n        [-1.5127,  1.1119,  0.0240, -0.7175],\n        [ 0.0837, -0.5080,  1.0393, -0.8134],\n        [ 0.5476, -0.8740,  2.1083, -0.9301],\n        [ 2.2264, -0.7628,  0.1427,  1.2580],\n        [-0.1776,  0.8092, -1.5062,  2.8540],\n        [-0.6710, -2.3110, -2.9075, -0.2702],\n        [ 0.1821,  1.3021, -0.4444,  0.7293],\n        [ 0.2201, -0.6899, -0.0610,  2.0738]], requires_grad=True)\n\n\nOnce we have the embeddings matrix, we can map input tokens to their corresponding embeddings.\n\nstage1.embeddings.v0()\n\nPseudo-randomly initialized embedding layer:\n╒══════════════════════════╤══════════════════════════════════════════════════════════════════════════════╕\n│ Vocab Size               │ 10                                                                           │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Output Dimension         │ 3                                                                            │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Embedding Layer          │ Embedding(10, 3)                                                             │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Layer Weights            │ Parameter containing: tensor([[-1.1258, -1.1524, -0.2506],         [-0.4339, │\n│                          │ 0.8487,  0.6920],         [-0.3160, -2.1152,  0.3223],         [-1.2633,     │\n│                          │ 0.3500,  0.3081],         [ 0.1198,  1.2377, -0.1435],         [-0.1116,     │\n│                          │ -0.6136,  0.0316],         [-0.4927,  0.2484,  0.4397],         [ 0.1124,    │\n│                          │ -0.8411, -2.3160],         [-0.1023,  0.7924, -0.2897],         [ 0.0525,    │\n│                          │ 0.5229,  2.3022]], requires_grad=True)                                       │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Embedding for token_id 5 │ tensor([-0.1116, -0.6136,  0.0316], grad_fn=&lt;EmbeddingBackward0&gt;)            │\n╘══════════════════════════╧══════════════════════════════════════════════════════════════════════════════╛\n╒═══════════════════════════════════╤═══════════════════════════════════════════════════════════════════════════╕\n│ Embedding for token_ids [2, 4, 6] │ tensor([[-0.3160, -2.1152,  0.3223],         [ 0.1198,  1.2377, -0.1435], │\n│                                   │ [-0.4927,  0.2484,  0.4397]], grad_fn=&lt;EmbeddingBackward0&gt;)               │\n╘═══════════════════════════════════╧═══════════════════════════════════════════════════════════════════════════╛\n\n\n\n\n3.2.3 V1\n\nData loaders create batches of token-ids for efficient processing\nBatching is valuable for large text corpora\nBatched processing leverages GPU acceleration when available\nEven on CPU, batching enables more efficient multi-threaded processing\nThe example demonstrates creating embeddings for “The Verdict” text using previously created data loader with batch processing\n\n\nstage1.embeddings.v1()\n\n╒════════════════╤═══════╕\n│ vocab_size     │ 50257 │\n├────────────────┼───────┤\n│ embedding_size │   256 │\n├────────────────┼───────┤\n│ input_length   │     4 │\n├────────────────┼───────┤\n│ batch_size     │     8 │\n╘════════════════╧═══════╛\nEmbedding Layer: Parameter containing:\ntensor([[ 0.9383,  0.4889, -0.6731,  ...,  1.2948,  1.4628, -0.6204],\n        [ 0.6257, -1.2231, -0.6232,  ...,  0.3260,  0.5352,  1.9733],\n        [-1.4115, -1.0295,  0.1267,  ...,  0.5027, -0.8871,  1.9974],\n        ...,\n        [ 0.6928, -0.5382, -0.8726,  ..., -0.5148,  0.9695,  0.7689],\n        [-0.5866,  0.6971,  1.8386,  ...,  0.4298, -0.5139,  1.6624],\n        [ 0.6073,  0.2991,  0.7669,  ..., -1.3811, -1.4284, -0.5630]],\n       requires_grad=True)\nInputs shape: torch.Size([8, 4])\nTargets shape: torch.Size([8, 4])\nInput tensor shape:  torch.Size([1, 4])\nInput Tensor: tensor([[39936, 24254,  7996, 42174]])\nOutput tensor shape:  torch.Size([1, 4, 256])\nOutput Tensor: tensor([[[-0.9905,  0.4149, -0.1217,  ...,  2.3362, -0.5502,  0.3072],\n         [ 2.0188,  0.2669, -0.0151,  ..., -0.1302,  0.0308, -0.0452],\n         [ 1.7518,  1.2162, -1.0058,  ..., -1.2053, -0.8477, -0.3506],\n         [ 0.3572, -1.6816,  1.1135,  ...,  0.8234,  0.5311, -0.3427]]],\n       grad_fn=&lt;EmbeddingBackward0&gt;)\n\n\n\n\n3.2.4 V2 - Using word positions\n\nTaking the previous example and thinking further, while embeddings capture semantic relationships in a denser space, we also need to encode token positions in sentences.\n\nA word’s meaning can change based on its position\nA sentence’s meaning can change based on word order\nWe hypothesize this and hope our neural network architecture will learn it\n\nWe’ll abstract away the details of position encoding implementation:\n\nNo clean notion of position exists (no defined start/end for text we process)\nFocus on the current input and calculations relative to it\n\nEven within the current input batch, position is a hazy concept due to sliding windows:\n\nOptions include using absolute positions within current sequence/batch\nOr encoding relative positions instead\n\n\n\nstage1.embeddings.v2pos()\n\n╒════════════════╤═══════╕\n│ vocab_size     │ 50257 │\n├────────────────┼───────┤\n│ embedding_size │   256 │\n├────────────────┼───────┤\n│ input_length   │     4 │\n├────────────────┼───────┤\n│ batch_size     │     8 │\n╘════════════════╧═══════╛\nEmbedding Layer: Parameter containing:\ntensor([[ 0.7480,  2.0246,  0.8172,  ...,  1.4958,  0.9920, -0.4635],\n        [-0.0083,  2.1477, -0.6221,  ..., -0.6456, -0.7785, -0.0448],\n        [ 0.3099,  0.7856,  1.1800,  ...,  0.0087, -0.3606, -1.5200],\n        ...,\n        [ 0.6470,  1.1495,  1.0626,  ...,  1.2715, -0.1108, -0.4586],\n        [ 0.0704, -1.2130, -1.3772,  ..., -1.3077,  0.3081,  0.8306],\n        [ 0.3290,  0.2603, -1.1474,  ..., -0.3902, -0.7557, -0.1635]],\n       requires_grad=True)\nPositional Embedding Layer: Parameter containing:\ntensor([[-1.2746,  2.2625, -2.0476,  ..., -0.0991, -0.1806,  0.0748],\n        [ 1.5418, -0.9089, -0.5957,  ..., -0.9257,  1.2022,  0.9211],\n        [-0.4068, -0.5110,  0.1881,  ..., -0.0294, -0.7648, -1.0097],\n        [ 1.6700, -1.1958, -1.2150,  ...,  0.0909,  0.1570, -2.0347]],\n       requires_grad=True)\nInput shape:  torch.Size([8, 4, 256])\nPlain token embeddings:  tensor([[[ 0.4318,  0.5522,  0.9293,  ...,  0.8221,  0.5407, -0.2860],\n         [-1.2446, -0.1105,  0.8851,  ..., -0.6168, -0.1016,  0.8931],\n         [-1.2060, -1.4052,  0.7802,  ...,  0.0574,  0.4872,  1.6930],\n         [ 1.4304, -1.1654, -0.3654,  ...,  2.6416, -1.2475,  0.5927]],\n\n        [[-0.2098, -2.4730,  0.5364,  ...,  1.1667, -0.3026, -0.9157],\n         [-1.2725, -1.0119, -0.2631,  ...,  0.9508,  0.6296,  0.0675],\n         [-2.2059, -1.3065, -0.8812,  ...,  1.1935, -0.9095, -0.8640],\n         [ 0.6062,  0.6820, -0.1552,  ..., -3.4933, -1.6555, -0.2279]],\n\n        [[ 0.7390, -1.6588,  1.5115,  ...,  0.3389, -0.9614, -0.7456],\n         [ 0.5239, -0.7570, -0.1204,  ..., -0.2197, -1.0866, -0.7499],\n         [-1.2727,  0.1583, -2.1473,  ..., -0.9593, -0.7086, -0.1224],\n         [ 0.7573, -0.7136,  0.9684,  ..., -0.1977, -0.0050,  1.3835]],\n\n        ...,\n\n        [[-0.0757, -0.3070, -0.9718,  ..., -0.8089,  0.4655,  1.1395],\n         [ 0.1489,  0.1279, -0.8199,  ...,  0.1329, -0.4307,  0.8254],\n         [ 0.2233,  0.7468, -0.3207,  ..., -0.9275,  2.2948,  1.0906],\n         [-0.1399, -0.3639, -1.8264,  ...,  0.3288, -0.4609,  0.9846]],\n\n        [[-1.2727,  0.1583, -2.1473,  ..., -0.9593, -0.7086, -0.1224],\n         [-1.2725, -1.0119, -0.2631,  ...,  0.9508,  0.6296,  0.0675],\n         [ 1.3725, -1.0106, -0.0334,  ..., -0.9763,  0.0051,  0.5848],\n         [ 1.3725, -1.0106, -0.0334,  ..., -0.9763,  0.0051,  0.5848]],\n\n        [[-1.2725, -1.0119, -0.2631,  ...,  0.9508,  0.6296,  0.0675],\n         [ 1.3725, -1.0106, -0.0334,  ..., -0.9763,  0.0051,  0.5848],\n         [ 1.3725, -1.0106, -0.0334,  ..., -0.9763,  0.0051,  0.5848],\n         [ 1.3725, -1.0106, -0.0334,  ..., -0.9763,  0.0051,  0.5848]]],\n       grad_fn=&lt;EmbeddingBackward0&gt;)\nPositional embeddings:  tensor([[[-0.8428,  2.8148, -1.1183,  ...,  0.7230,  0.3600, -0.2112],\n         [ 0.2972, -1.0194,  0.2894,  ..., -1.5425,  1.1006,  1.8142],\n         [-1.6128, -1.9162,  0.9683,  ...,  0.0281, -0.2776,  0.6833],\n         [ 3.1005, -2.3613, -1.5804,  ...,  2.7324, -1.0906, -1.4421]],\n\n        [[-1.4844, -0.2104, -1.5112,  ...,  1.0675, -0.4832, -0.8409],\n         [ 0.2693, -1.9208, -0.8589,  ...,  0.0251,  1.8318,  0.9886],\n         [-2.6128, -1.8175, -0.6931,  ...,  1.1642, -1.6742, -1.8737],\n         [ 2.2762, -0.5139, -1.3702,  ..., -3.4024, -1.4985, -2.2626]],\n\n        [[-0.5357,  0.6037, -0.5361,  ...,  0.2398, -1.1420, -0.6708],\n         [ 2.0657, -1.6659, -0.7162,  ..., -1.1454,  0.1156,  0.1713],\n         [-1.6795, -0.3528, -1.9592,  ..., -0.9887, -1.4734, -1.1320],\n         [ 2.4273, -1.9094, -0.2466,  ..., -0.1069,  0.1520, -0.6512]],\n\n        ...,\n\n        [[-1.3503,  1.9556, -3.0194,  ..., -0.9080,  0.2848,  1.2143],\n         [ 1.6907, -0.7810, -1.4156,  ..., -0.7928,  0.7715,  1.7465],\n         [-0.1835,  0.2357, -0.1326,  ..., -0.9569,  1.5301,  0.0809],\n         [ 1.5301, -1.5597, -3.0414,  ...,  0.4197, -0.3039, -1.0502]],\n\n        [[-2.5473,  2.4208, -4.1948,  ..., -1.0584, -0.8893, -0.0476],\n         [ 0.2693, -1.9208, -0.8589,  ...,  0.0251,  1.8318,  0.9886],\n         [ 0.9656, -1.5217,  0.1547,  ..., -1.0056, -0.7597, -0.4248],\n         [ 3.0425, -2.2065, -1.2484,  ..., -0.8854,  0.1621, -1.4499]],\n\n        [[-2.5472,  1.2507, -2.3107,  ...,  0.8517,  0.4489,  0.1423],\n         [ 2.9143, -1.9195, -0.6292,  ..., -1.9020,  1.2073,  1.5059],\n         [ 0.9656, -1.5217,  0.1547,  ..., -1.0056, -0.7597, -0.4248],\n         [ 3.0425, -2.2065, -1.2484,  ..., -0.8854,  0.1621, -1.4499]]],\n       grad_fn=&lt;AddBackward0&gt;)"
  }
]